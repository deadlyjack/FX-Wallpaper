/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwallpaper"] = self["webpackChunkwallpaper"] || []).push([["vendors-node_modules_pinch-zoom-element_dist_pinch-zoom_es_js"],{

/***/ "./node_modules/pinch-zoom-element/dist/pinch-zoom.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/pinch-zoom-element/dist/pinch-zoom.es.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pointer_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pointer-tracker */ \"./node_modules/pointer-tracker/dist/PointerTracker.mjs\");\n\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"pinch-zoom {\\n  display: block;\\n  overflow: hidden;\\n  touch-action: none;\\n  --scale: 1;\\n  --x: 0;\\n  --y: 0;\\n}\\n\\npinch-zoom > * {\\n  transform: translate(var(--x), var(--y)) scale(var(--scale));\\n  transform-origin: 0 0;\\n  will-change: transform;\\n}\\n\";\nstyleInject(css);\n\nconst minScaleAttr = 'min-scale';\r\nfunction getDistance(a, b) {\r\n    if (!b)\r\n        return 0;\r\n    return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\r\n}\r\nfunction getMidpoint(a, b) {\r\n    if (!b)\r\n        return a;\r\n    return {\r\n        clientX: (a.clientX + b.clientX) / 2,\r\n        clientY: (a.clientY + b.clientY) / 2,\r\n    };\r\n}\r\nfunction getAbsoluteValue(value, max) {\r\n    if (typeof value === 'number')\r\n        return value;\r\n    if (value.trimRight().endsWith('%')) {\r\n        return max * parseFloat(value) / 100;\r\n    }\r\n    return parseFloat(value);\r\n}\r\n// I'd rather use DOMMatrix/DOMPoint here, but the browser support isn't good enough.\r\n// Given that, better to use something everything supports.\r\nlet cachedSvg;\r\nfunction getSVG() {\r\n    return cachedSvg || (cachedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'));\r\n}\r\nfunction createMatrix() {\r\n    return getSVG().createSVGMatrix();\r\n}\r\nfunction createPoint() {\r\n    return getSVG().createSVGPoint();\r\n}\r\nconst MIN_SCALE = 0.01;\r\nclass PinchZoom extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        // Current transform.\r\n        this._transform = createMatrix();\r\n        // Watch for children changes.\r\n        // Note this won't fire for initial contents,\r\n        // so _stageElChange is also called in connectedCallback.\r\n        new MutationObserver(() => this._stageElChange())\r\n            .observe(this, { childList: true });\r\n        // Watch for pointers\r\n        const pointerTracker = new pointer_tracker__WEBPACK_IMPORTED_MODULE_0__.default(this, {\r\n            start: (pointer, event) => {\r\n                // We only want to track 2 pointers at most\r\n                if (pointerTracker.currentPointers.length === 2 || !this._positioningEl)\r\n                    return false;\r\n                event.preventDefault();\r\n                return true;\r\n            },\r\n            move: (previousPointers) => {\r\n                this._onPointerMove(previousPointers, pointerTracker.currentPointers);\r\n            },\r\n        });\r\n        this.addEventListener('wheel', event => this._onWheel(event));\r\n    }\r\n    static get observedAttributes() { return [minScaleAttr]; }\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n        if (name === minScaleAttr) {\r\n            if (this.scale < this.minScale) {\r\n                this.setTransform({ scale: this.minScale });\r\n            }\r\n        }\r\n    }\r\n    get minScale() {\r\n        const attrValue = this.getAttribute(minScaleAttr);\r\n        if (!attrValue)\r\n            return MIN_SCALE;\r\n        const value = parseFloat(attrValue);\r\n        if (Number.isFinite(value))\r\n            return Math.max(MIN_SCALE, value);\r\n        return MIN_SCALE;\r\n    }\r\n    set minScale(value) {\r\n        this.setAttribute(minScaleAttr, String(value));\r\n    }\r\n    connectedCallback() {\r\n        this._stageElChange();\r\n    }\r\n    get x() {\r\n        return this._transform.e;\r\n    }\r\n    get y() {\r\n        return this._transform.f;\r\n    }\r\n    get scale() {\r\n        return this._transform.a;\r\n    }\r\n    /**\r\n     * Change the scale, adjusting x/y by a given transform origin.\r\n     */\r\n    scaleTo(scale, opts = {}) {\r\n        let { originX = 0, originY = 0, } = opts;\r\n        const { relativeTo = 'content', allowChangeEvent = false, } = opts;\r\n        const relativeToEl = (relativeTo === 'content' ? this._positioningEl : this);\r\n        // No content element? Fall back to just setting scale\r\n        if (!relativeToEl || !this._positioningEl) {\r\n            this.setTransform({ scale, allowChangeEvent });\r\n            return;\r\n        }\r\n        const rect = relativeToEl.getBoundingClientRect();\r\n        originX = getAbsoluteValue(originX, rect.width);\r\n        originY = getAbsoluteValue(originY, rect.height);\r\n        if (relativeTo === 'content') {\r\n            originX += this.x;\r\n            originY += this.y;\r\n        }\r\n        else {\r\n            const currentRect = this._positioningEl.getBoundingClientRect();\r\n            originX -= currentRect.left;\r\n            originY -= currentRect.top;\r\n        }\r\n        this._applyChange({\r\n            allowChangeEvent,\r\n            originX,\r\n            originY,\r\n            scaleDiff: scale / this.scale,\r\n        });\r\n    }\r\n    /**\r\n     * Update the stage with a given scale/x/y.\r\n     */\r\n    setTransform(opts = {}) {\r\n        const { scale = this.scale, allowChangeEvent = false, } = opts;\r\n        let { x = this.x, y = this.y, } = opts;\r\n        // If we don't have an element to position, just set the value as given.\r\n        // We'll check bounds later.\r\n        if (!this._positioningEl) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Get current layout\r\n        const thisBounds = this.getBoundingClientRect();\r\n        const positioningElBounds = this._positioningEl.getBoundingClientRect();\r\n        // Not displayed. May be disconnected or display:none.\r\n        // Just take the values, and we'll check bounds later.\r\n        if (!thisBounds.width || !thisBounds.height) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Create points for _positioningEl.\r\n        let topLeft = createPoint();\r\n        topLeft.x = positioningElBounds.left - thisBounds.left;\r\n        topLeft.y = positioningElBounds.top - thisBounds.top;\r\n        let bottomRight = createPoint();\r\n        bottomRight.x = positioningElBounds.width + topLeft.x;\r\n        bottomRight.y = positioningElBounds.height + topLeft.y;\r\n        // Calculate the intended position of _positioningEl.\r\n        const matrix = createMatrix()\r\n            .translate(x, y)\r\n            .scale(scale)\r\n            // Undo current transform\r\n            .multiply(this._transform.inverse());\r\n        topLeft = topLeft.matrixTransform(matrix);\r\n        bottomRight = bottomRight.matrixTransform(matrix);\r\n        // Ensure _positioningEl can't move beyond out-of-bounds.\r\n        // Correct for x\r\n        if (topLeft.x > thisBounds.width) {\r\n            x += thisBounds.width - topLeft.x;\r\n        }\r\n        else if (bottomRight.x < 0) {\r\n            x += -bottomRight.x;\r\n        }\r\n        // Correct for y\r\n        if (topLeft.y > thisBounds.height) {\r\n            y += thisBounds.height - topLeft.y;\r\n        }\r\n        else if (bottomRight.y < 0) {\r\n            y += -bottomRight.y;\r\n        }\r\n        this._updateTransform(scale, x, y, allowChangeEvent);\r\n    }\r\n    /**\r\n     * Update transform values without checking bounds. This is only called in setTransform.\r\n     */\r\n    _updateTransform(scale, x, y, allowChangeEvent) {\r\n        // Avoid scaling to zero\r\n        if (scale < this.minScale)\r\n            return;\r\n        // Return if there's no change\r\n        if (scale === this.scale &&\r\n            x === this.x &&\r\n            y === this.y)\r\n            return;\r\n        this._transform.e = x;\r\n        this._transform.f = y;\r\n        this._transform.d = this._transform.a = scale;\r\n        this.style.setProperty('--x', this.x + 'px');\r\n        this.style.setProperty('--y', this.y + 'px');\r\n        this.style.setProperty('--scale', this.scale + '');\r\n        if (allowChangeEvent) {\r\n            const event = new Event('change', { bubbles: true });\r\n            this.dispatchEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the direct children of this element change.\r\n     * Until we have have shadow dom support across the board, we\r\n     * require a single element to be the child of <pinch-zoom>, and\r\n     * that's the element we pan/scale.\r\n     */\r\n    _stageElChange() {\r\n        this._positioningEl = undefined;\r\n        if (this.children.length === 0)\r\n            return;\r\n        this._positioningEl = this.children[0];\r\n        if (this.children.length > 1) {\r\n            console.warn('<pinch-zoom> must not have more than one child.');\r\n        }\r\n        // Do a bounds check\r\n        this.setTransform({ allowChangeEvent: true });\r\n    }\r\n    _onWheel(event) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        event.preventDefault();\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        let { deltaY } = event;\r\n        const { ctrlKey, deltaMode } = event;\r\n        if (deltaMode === 1) { // 1 is \"lines\", 0 is \"pixels\"\r\n            // Firefox uses \"lines\" for some types of mouse\r\n            deltaY *= 15;\r\n        }\r\n        // ctrlKey is true when pinch-zooming on a trackpad.\r\n        const divisor = ctrlKey ? 100 : 300;\r\n        const scaleDiff = 1 - deltaY / divisor;\r\n        this._applyChange({\r\n            scaleDiff,\r\n            originX: event.clientX - currentRect.left,\r\n            originY: event.clientY - currentRect.top,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    _onPointerMove(previousPointers, currentPointers) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        // Combine next points with previous points\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        // For calculating panning movement\r\n        const prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);\r\n        const newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);\r\n        // Midpoint within the element\r\n        const originX = prevMidpoint.clientX - currentRect.left;\r\n        const originY = prevMidpoint.clientY - currentRect.top;\r\n        // Calculate the desired change in scale\r\n        const prevDistance = getDistance(previousPointers[0], previousPointers[1]);\r\n        const newDistance = getDistance(currentPointers[0], currentPointers[1]);\r\n        const scaleDiff = prevDistance ? newDistance / prevDistance : 1;\r\n        this._applyChange({\r\n            originX, originY, scaleDiff,\r\n            panX: newMidpoint.clientX - prevMidpoint.clientX,\r\n            panY: newMidpoint.clientY - prevMidpoint.clientY,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    /** Transform the view & fire a change event */\r\n    _applyChange(opts = {}) {\r\n        const { panX = 0, panY = 0, originX = 0, originY = 0, scaleDiff = 1, allowChangeEvent = false, } = opts;\r\n        const matrix = createMatrix()\r\n            // Translate according to panning.\r\n            .translate(panX, panY)\r\n            // Scale about the origin.\r\n            .translate(originX, originY)\r\n            // Apply current translate\r\n            .translate(this.x, this.y)\r\n            .scale(scaleDiff)\r\n            .translate(-originX, -originY)\r\n            // Apply current scale.\r\n            .scale(this.scale);\r\n        // Convert the transform into basic translate & scale.\r\n        this.setTransform({\r\n            allowChangeEvent,\r\n            scale: matrix.a,\r\n            x: matrix.e,\r\n            y: matrix.f,\r\n        });\r\n    }\r\n}\n\ncustomElements.define('pinch-zoom', PinchZoom);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PinchZoom);\n\n\n//# sourceURL=webpack://wallpaper/./node_modules/pinch-zoom-element/dist/pinch-zoom.es.js?");

/***/ }),

/***/ "./node_modules/pointer-tracker/dist/PointerTracker.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pointer-tracker/dist/PointerTracker.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            return this.nativePointer.getCoalescedEvents().map((p) => new Pointer(p));\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => self.PointerEvent && event instanceof PointerEvent;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (event.button !== 0 /* Left */)\r\n                return;\r\n            if (!this._triggerPointerStart(new Pointer(event), event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.addEventListener('pointerup', this._pointerEnd);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = 'changedTouches' in event // Shortcut for 'is touch event'.\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            const cancelled = event.type === 'touchcancel' || event.type === 'pointercancel';\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        // Add listeners\r\n        if (self.PointerEvent) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart);\r\n            this._element.addEventListener('touchstart', this._touchStart);\r\n            this._element.addEventListener('touchmove', this._move);\r\n            this._element.addEventListener('touchend', this._touchEnd);\r\n            this._element.addEventListener('touchcancel', this._touchEnd);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PointerTracker);\n\n\n//# sourceURL=webpack://wallpaper/./node_modules/pointer-tracker/dist/PointerTracker.mjs?");

/***/ })

}]);